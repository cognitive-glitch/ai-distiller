<file path="source.cpp">
#include "iostream"
#include "string"
#include "vector"
#include "memory"
#include "algorithm"
#include "iterator"
#include "functional"
#include "map"
#include "set"
class Employee {
};
class LibraryItem {
    LibraryItem(const & id, const & title) {
        {}
    }
    virtual ~LibraryItem() {
        = default
    }
    const & getId() const {
        { return id_; }
    }
    const & getTitle() const {
        { return title_; }
    }
    bool isAvailable() const {
        { return isAvailable_; }
    }
    virtual bool borrow() {
        {
                if (isAvailable_) {
                    isAvailable_ = false;
                    return true;
                }
                return false;
            }
    }
    virtual void returnItem() {
        {
                isAvailable_ = true;
            }
    }
    virtual getDetails() const = 0
    void setAvailability(bool status) {
        { isAvailable_ = status; }
    }
    auto id_;
    auto title_;
    bool isAvailable_;
};
class Book : public LibraryItem {
    Book(const & id, const & title, const & author, const & isbn) {
        {}
    }
    const & getAuthor() const {
        { return author_; }
    }
    const & getISBN() const {
        { return isbn_; }
    }
    getDetails() const {
        {
                return "Book: " + getTitle() + " by " + author_ + " (ISBN: " + isbn_ + ")";
            }
    }
    auto author_;
    auto isbn_;
};
class Magazine : public LibraryItem {
    Magazine(const & id, const & title, int issueNumber, const & publisher) {
        {}
    }
    int getIssueNumber() const {
        { return issueNumber_; }
    }
    const & getPublisher() const {
        { return publisher_; }
    }
    getDetails() const {
        {
                return "Magazine: " + getTitle() + " Issue #" + 
                       std::to_string(issueNumber_) + " (" + publisher_ + ")";
            }
    }
    int issueNumber_;
    auto publisher_;
};
class LibraryCatalog {
    void addItem(auto item) {
        {
                items_[item->getId()] = std::move(item);
            }
    }
    LibraryItem* findItem(const & id) {
        {
                auto it = items_.find(id);
                return (it != items_.end()) ? it->second.get() : nullptr;
            }
    }
    getAvailableItems() const {
        {
                std::vector<LibraryItem*> available;
                for (const auto& pair : items_) {
                    if (pair.second->isAvailable()) {
                        available.push_back(pair.second.get());
                    }
                }
                return available;
            }
    }
    searchByTitle(const & searchTerm) const {
        {
                std::vector<LibraryItem*> results;
                
                // Convert search term to lowercase
                std::string lowerSearchTerm = searchTerm;
                std::transform(lowerSearchTerm.begin(), lowerSearchTerm.end(),
                              lowerSearchTerm.begin(), ::tolower);
                
                for (const auto& pair : items_) {
                    std::string lowerTitle = pair.second->getTitle();
                    std::transform(lowerTitle.begin(), lowerTitle.end(),
                                  lowerTitle.begin(), ::tolower);
                    
                    if (lowerTitle.find(lowerSearchTerm) != std::string::npos) {
                        results.push_back(pair.second.get());
                    }
                }
                
                return results;
            }
    }
    size_t getItemCount() const {
        { return items_.size(); }
    }
    auto items_;
};
struct TitleComparator {
    bool operator()(const LibraryItem* a, const LibraryItem* b) const {
        {
                return a->getTitle() < b->getTitle();
            }
    }
};
class LibraryUtils {
    static void sortByTitle(& items) {
        {
                std::sort(items.begin(), items.end(), TitleComparator{});
            }
    }
    template<typename Predicate>
    static filterItems(const & items, Predicate pred) {
        {
                std::vector<LibraryItem*> filtered;
                std::copy_if(items.begin(), items.end(), 
                            std::back_inserter(filtered), pred);
                return filtered;
            }
    }
    template<typename ItemType>
    static size_t countItemsByType(const & items) {
        {
                return std::count_if(items.begin(), items.end(),
                                   [](const LibraryItem* item) {
                                       return dynamic_cast<const ItemType*>(item) != nullptr;
                                   });
            }
    }
    LibraryUtils() {
        = delete
    }
};
class FileManager {
    FileManager(const & filename) {
        {}
    }
    ~FileManager() {
        {
                if (isOpen_) {
                    close();
                }
            }
    }
    FileManager(const FileManager ) {
        = delete
    }
    FileManager& operator=(const FileManager ) {
        = delete
    }
    bool open() {
        {
                // Simulate file opening
                isOpen_ = true;
                return true;
            }
    }
    void close() {
        {
                if (isOpen_) {
                    // Simulate file closing
                    isOpen_ = false;
                }
            }
    }
    bool isOpen() const {
        { return isOpen_; }
    }
};
void demonstrateLibrarySystem() {
    {
        using namespace LibrarySystem;
        
        // Create catalog
        LibraryCatalog catalog;
        
        // Add items
        catalog.addItem(std::make_unique<Book>("B001", "The C++ Programming Language", 
                                              "Bjarne Stroustrup", "978-0321563842"));
        catalog.addItem(std::make_unique<Book>("B002", "Effective C++", 
                                              "Scott Meyers", "978-0321334879"));
        catalog.addItem(std::make_unique<Magazine>("M001", "C++ Today", 42, "Tech Publications"));
        
        // Search and demonstrate
        auto cppItems = catalog.searchByTitle("C++");
        LibraryUtils::sortByTitle(cppItems);
        
        // Filter available items
        auto availableItems = LibraryUtils::filterItems(
            cppItems, [](const LibraryItem* item) { return item->isAvailable(); });
        
        // Count books
        size_t bookCount = LibraryUtils::countItemsByType<Book>(cppItems);
        
        std::cout << "Found " << cppItems.size() << " C++ related items" << std::endl;
        std::cout << "Available: " << availableItems.size() << std::endl;
        std::cout << "Books: " << bookCount << std::endl;
    }
}
</file>
