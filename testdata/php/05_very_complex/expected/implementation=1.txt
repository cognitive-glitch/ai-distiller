<file path="/home/janreges/ai-distiller/testdata/php/05_very_complex/source.php">
class ProxyTarget {
    readonly array $interceptMethods;
    readonly string $proxyClass;
    __construct(array $interceptMethods, string $proxyClass)
}
class Intercept {
    readonly string $before;
    readonly string $after;
    readonly bool $cache;
    __construct(string $before, string $after, bool $cache)
}
class Memoize {
    readonly int $ttl;
    readonly string $keyGenerator;
    __construct(int $ttl, string $keyGenerator)
}
class DynamicProxyFactory {
    __construct() {
$this->proxyCache = new WeakMap();
        $this->memoCache = new SplObjectStorage();
    }
    createProxy(object $target): object {
$reflection = new ReflectionClass($target);
        $proxyAttributes = $reflection->getAttributes(ProxyTarget::class);
        
        if (empty($proxyAttributes)) {
            throw new \InvalidArgumentException('Target class must have ProxyTarget attribute');
        }

        $proxyConfig = $proxyAttributes[0]->newInstance();
        
        // Check cache first
        if (isset($this->proxyCache[$target])) {
            return $this->proxyCache[$target];
        }

        $proxy = $this->generateProxy($target, $reflection, $proxyConfig);
        $this->proxyCache[$target] = $proxy;
        
        return $proxy;
    }
    interceptMethod(object $target, string $methodName, array $arguments): mixed {
$reflection = new ReflectionClass($target);
        $method = $reflection->getMethod($methodName);
        
        // Check for memoization
        $memoizeAttributes = $method->getAttributes(Memoize::class);
        if (!empty($memoizeAttributes)) {
            $memoConfig = $memoizeAttributes[0]->newInstance();
            $cacheKey = $this->generateCacheKey($target, $methodName, $arguments, $memoConfig);
            
            if ($this->memoCache->contains($target) && isset($this->memoCache[$target][$cacheKey])) {
                return $this->memoCache[$target][$cacheKey]['value'];
            }
        }

        // Check for interceptors
        $interceptAttributes = $method->getAttributes(Intercept::class);
        $interceptConfig = !empty($interceptAttributes) ? $interceptAttributes[0]->newInstance() : null;

        // Before interceptor
        if ($interceptConfig && $interceptConfig->before) {
            $this->callInterceptor($target, $interceptConfig->before, $arguments);
        }

        // Call original method
        $result = $method->invokeArgs($target, $arguments);

        // After interceptor
        if ($interceptConfig && $interceptConfig->after) {
            $this->callInterceptor($target, $interceptConfig->after, [$result]);
        }

        // Store in memo cache
        if (!empty($memoizeAttributes)) {
            if (!$this->memoCache->contains($target)) {
                $this->memoCache[$target] = [];
            }
            $this->memoCache[$target][$cacheKey] = [
                'value' => $result,
                'timestamp' => time(),
                'ttl' => $memoConfig->ttl
            ];
        }

        return $result;
    }
}
interface ProxyInterface {
    __getTarget(): object
}
class AsyncOperationManager {
    execute(string $id, Closure $operation): void {
$this->fibers[$id] = new Fiber($operation);
        $this->fibers[$id]->start();
    }
    resume(string $id, mixed $value): void {
if (isset($this->fibers[$id]) && $this->fibers[$id]->isSuspended()) {
            try {
                $result = $this->fibers[$id]->resume($value);
                if ($this->fibers[$id]->isTerminated()) {
                    $this->results[$id] = $result;
                    unset($this->fibers[$id]);
                }
            } catch (FiberError $e) {
                $this->results[$id] = ['error' => $e->getMessage()];
                unset($this->fibers[$id]);
            }
        }
    }
    getResult(string $id): mixed {
return $this->results[$id] ?? null;
    }
    isComplete(string $id): bool {
return isset($this->results[$id]);
    }
    waitAll(): Generator {
while (!empty($this->fibers)) {
            foreach (array_keys($this->fibers) as $id) {
                $this->resume($id);
                if ($this->isComplete($id)) {
                    yield $id => $this->getResult($id);
                }
            }
            
            // Yield control to prevent blocking
            Fiber::suspend();
        }
    }
}
class OrderService {
    __construct() {
$this->asyncManager = new AsyncOperationManager();
    }
    calculatePrice(array $items, string $currency): float {
$total = 0.0;
        
        foreach ($items as $item) {
            $total += $item['price'] * $item['quantity'];
        }
        
        // Simulate complex calculation
        usleep(100000); // 100ms
        
        return $total * $this->getCurrencyMultiplier($currency);
    }
    processOrder(array $orderData): string {
$orderId = uniqid('order_');
        
        $this->asyncManager->execute($orderId, function() use ($orderData, $orderId) {
            // Simulate async processing
            Fiber::suspend();
            
            // Process payment
            $this->processPayment($orderData['payment']);
            Fiber::suspend();
            
            // Update inventory
            $this->updateInventory($orderData['items']);
            Fiber::suspend();
            
            // Send confirmation
            $this->sendConfirmation($orderData['customer']);
            
            return ['order_id' => $orderId, 'status' => 'completed'];
        });
        
        return $orderId;
    }
    generatePriceKey(string $methodName, array $arguments): string {
[$items, $currency] = $arguments;
        return md5($methodName . serialize($items) . $currency);
    }
    getOrderStatus(string $orderId): array Status information {
if ($this->asyncManager->isComplete($orderId)) {
            return $this->asyncManager->getResult($orderId);
        }
        
        return ['order_id' => $orderId, 'status' => 'processing'];
    }
}
class MetaProgrammingDemo {
    createDynamicClass(string $className, array $properties, array $methods): string {
$classCode = "class {$className} {\n";
        
        // Add properties
        foreach ($properties as $name => $type) {
            $classCode .= "    public {$type} \${$name};\n";
        }
        
        // Add methods
        foreach ($methods as $methodName => $methodCode) {
            $classCode .= "\n    public function {$methodName}() {\n";
            $classCode .= "        {$methodCode}\n";
            $classCode .= "    }\n";
        }
        
        $classCode .= "}\n";
        
        eval($classCode);
        
        return $className;
    }
    addMethod(object $object, string $methodName, Closure $implementation): void {
$boundClosure = $implementation->bindTo($object, $object);
        $object->$methodName = $boundClosure;
    }
    analyzeObject(object $object): array Analysis result {
$reflection = new ReflectionClass($object);
        
        return [
            'class' => $reflection->getName(),
            'interfaces' => $reflection->getInterfaceNames(),
            'traits' => $reflection->getTraitNames(),
            'properties' => $this->analyzeProperties($reflection),
            'methods' => $this->analyzeMethods($reflection),
            'constants' => $reflection->getConstants(),
            'attributes' => $this->analyzeAttributes($reflection),
        ];
    }
}
</file>
