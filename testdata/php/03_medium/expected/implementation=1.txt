<file path="/home/janreges/ai-distiller/testdata/php/03_medium/source.php">
interface ContainerInterface {
    register(string $id, callable|object $service): void
    resolve(string $id): mixed
    has(string $id): bool
}
class Container implements ContainerInterface {
    register(string $id, callable|object $service): void {
$this->services[$id] = $service;
        unset($this->instances[$id]); // Clear cached instance
    }
    resolve(string $id): mixed {
if (isset($this->instances[$id])) {
            return $this->instances[$id];
        }

        if (!isset($this->services[$id])) {
            throw new InvalidArgumentException("Service '{$id}' not found");
        }

        $service = $this->services[$id];
        
        $instance = is_callable($service) ? $service($this) : $service;
        $this->instances[$id] = $instance;
        
        return $instance;
    }
    has(string $id): bool {
return isset($this->services[$id]);
    }
    autowire(string $className): object {
$reflection = new ReflectionClass($className);
        
        if (!$reflection->isInstantiable()) {
            throw new InvalidArgumentException("Class '{$className}' is not instantiable");
        }

        $constructor = $reflection->getConstructor();
        if (!$constructor) {
            return $reflection->newInstance();
        }

        $dependencies = [];
        foreach ($constructor->getParameters() as $parameter) {
            $type = $parameter->getType();
            if ($type && !$type->isBuiltin()) {
                $dependencies[] = $this->resolve($type->getName());
            } else {
                $dependencies[] = $parameter->getDefaultValue();
            }
        }

        return $reflection->newInstanceArgs($dependencies);
    }
}
interface RepositoryInterface {
    find(int $id): ?object
    findAll(): T[]
    save(object $entity): object
    delete(object $entity): void
}
abstract class AbstractRepository implements RepositoryInterface {
    find(int $id): ?object {
return $this->entities[$id] ?? null;
    }
    findAll(): array {
return array_values($this->entities);
    }
    save(object $entity): object {
$reflection = new ReflectionClass($entity);
        
        if ($reflection->hasMethod('getId') && $reflection->hasMethod('setId')) {
            $id = $entity->getId();
            if ($id === null) {
                $entity->setId($this->nextId++);
                $id = $entity->getId();
            }
            $this->entities[$id] = $entity;
        }
        
        return $entity;
    }
    delete(object $entity): void {
$reflection = new ReflectionClass($entity);
        
        if ($reflection->hasMethod('getId')) {
            $id = $entity->getId();
            if ($id !== null) {
                unset($this->entities[$id]);
            }
        }
    }
    findBy(Closure $criteria): Generator {
foreach ($this->entities as $entity) {
            if ($criteria($entity)) {
                yield $entity;
            }
        }
    }
}
interface EventInterface {
    getName(): string
    getData(): array
}
interface EventListenerInterface {
    handle(EventInterface $event): void
}
class EventDispatcher {
    subscribe(string $eventName, EventListenerInterface $listener): void {
$this->listeners[$eventName][] = $listener;
    }
    dispatch(EventInterface $event): void {
$eventName = $event->getName();
        
        if (!isset($this->listeners[$eventName])) {
            return;
        }

        foreach ($this->listeners[$eventName] as $listener) {
            $listener->handle($event);
        }
    }
    listen(string $eventName, Closure $handler): void {
$this->subscribe($eventName, new class($handler) implements EventListenerInterface {
            public function __construct(private Closure $handler) {}
            
            public function handle(EventInterface $event): void
            {
                ($this->handler)($event);
            }
        });
    }
}
class Event implements EventInterface {
    __construct(string $name, array $data)
    getName(): string {
return $this->name;
    }
    getData(): array {
return $this->data;
    }
}
class User {
    __construct(?int $id, string $name, string $email)
    getId(): ?int {
{ return $this->id; }
    }
    setId(int $id): void {
{ $this->id = $id; }
    }
    getName(): string {
{ return $this->name; }
    }
    getEmail(): string {
{ return $this->email; }
    }
}
class UserRepository extends AbstractRepository {
    findByEmailDomain(string $domain): Generator {
return $this->findBy(fn(User $user) => str_ends_with($user->getEmail(), "@{$domain}"));
    }
    getStatistics(): array {
$total = count($this->entities);
        $domains = [];
        
        foreach ($this->entities as $user) {
            $domain = substr($user->getEmail(), strpos($user->getEmail(), '@') + 1);
            $domains[$domain] = ($domains[$domain] ?? 0) + 1;
        }
        
        return [
            'total' => $total,
            'domains' => $domains,
        ];
    }
}
class UserService {
    __construct(UserRepository $repository, EventDispatcher $dispatcher)
    createUser(string $name, string $email): User {
$user = new User(null, $name, $email);
        $savedUser = $this->repository->save($user);
        
        $this->dispatcher->dispatch(new Event('user.created', [
            'user_id' => $savedUser->getId(),
            'name' => $name,
            'email' => $email,
        ]));
        
        return $savedUser;
    }
    getUserStatistics(): Generator {
yield 'total' => count($this->repository->findAll());
        yield 'by_domain' => $this->repository->getStatistics()['domains'];
        yield 'recent' => iterator_to_array($this->repository->findBy(
            fn(User $user) => $user->getId() > 0
        ));
    }
}
</file>
