<file path="source.rs">
// 05_very_complex.rs
// A test for procedural macros, GATs, and advanced generic concepts.
// --- Assume this proc-macro is defined in a separate crate ---
// use my_proc_macros::Configurable;
// To make this file self-contained, we define a dummy trait.
// A real parser would see `#[derive(Configurable)]` and need to handle it.

trait Configurable {
}
// --- End of proc-macro simulation ---
// A trait with a Generic Associated Type (GAT).
// `Reader` has its own lifetime `'a`, which is tied to `&'a self`.

trait DataSource {
}
// Method with complex generic bounds
// A struct that would use a procedural derive macro in a real project.
// The parser must handle attributes on the struct and its fields.
// #[derive(Configurable)] // This is what a real use-case would look like.

struct ServerConfig {
    pub host: String,
    pub port: u16,
}
// A dummy implementation to make the code runnable.
// A proc-macro would generate this automatically.

impl Configurable for ServerConfig {
}
// A function with a Higher-Rank Trait Bound (HRTB).
// The `F` closure must work for *any* lifetime `'a`.

fn process_all_sources(sources: Vec<&dyn DataSource>, mut processor: F)
// The type of `reader` is tied to the lifetime of `source` in this loop iteration.
// The closure `processor` must be able to handle this.
// Advanced trait with const generics and GATs

trait AdvancedContainer<const N: usize> {
}
// Implementation with const generics

struct FixedArray<T: Clone, const N: usize>;

impl FixedArray<T, N> {
    // Create new fixed array

    fn new() -> Self
    // Private validation method
    // Internal method for unsafe operations
}

impl AdvancedContainer<N> for FixedArray<T, N> {
}
// Advanced async trait with GATs

trait AsyncDataProcessor {
}
// Default implementation with complex bounds
</file>
