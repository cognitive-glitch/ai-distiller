<file path="/home/janreges/ai-distiller/testdata/kotlin/05_very_complex/source.kt">
import kotlinx.coroutines
import kotlinx.coroutines.channels
import kotlinx.coroutines.flow
import kotlin.reflect
import kotlin.reflect.full
import kotlin.contracts
import kotlin.experimental.ExperimentalTypeInference
import kotlin.properties.PropertyDelegateProvider
import kotlin.properties.ReadOnlyProperty
import kotlin.time.Duration.Companion.seconds
class AutoGenerate {
    var strategy: GenerationStrategy
    var includeMethods: Array
    var excludeMethods: Array
    constructor(strategy: GenerationStrategy, includeMethods: Array, excludeMethods: Array)
}
enum class GenerationStrategy {
    DEFAULT
    BUILDER
    FACTORY
    OBSERVER
    PROXY
}
class ConfigurationDsl {
}
class DatabaseContext {
    var connectionPool: ConnectionPool
    suspend withTransaction(block: TransactionScope.() -> T): T
}
class TransactionScope {
    var transactionId: String
    suspend execute(query: String, params: Any): T
    suspend rollback()
    suspend commit()
}
class ConnectionPool {
    suspend borrowConnection(): DatabaseConnection
    suspend returnConnection(connection: DatabaseConnection)
    getStatistics(): PoolStatistics
}
abstract class AdvancedGenericRepository {
    abstract suspend findWithProjection(query: Q, projector: (E) -> T): Flow<T>
    abstract suspend aggregateBy(query: Q, keySelector: (E) -> K, valueSelector: (E) -> V, aggregator: (K, List<V>) -> V): Map<K, V>
    inline transformAndValidate(entities: List, transformer: (E) -> T, validator: (T) -> U): List<U>
}
class Entity {
    var id: ID
    var version: Long
    var metadata: EntityMetadata
}
class Auditable {
    var auditInfo: AuditInfo
    updateAuditInfo(actor: String, action: String)
}
class Validatable {
    suspend validate(context: ValidationContext): ValidationResult
}
data class ValidationContext(var rules: List, var services: ServiceLocator, var currentUser: UserContext, var environment: Environment) {
}
class ServiceLocator {
    suspend resolve(type: KClass): T
    suspend resolveOptional(type: KClass): T?
    suspend resolveAll(type: KClass): List<T>
}
class ManagedProperty {
    -private var factory: 
    -private var lifecycle: PropertyLifecycle
    constructor(factory, lifecycle: PropertyLifecycle)
    override provideDelegate(thisRef: Any, property: KProperty): ReadOnlyProperty<Any?, T>
}
class PropertyLifecycle {
    suspend onCreate(name: String, value: T): T
    suspend onAccess(name: String, value: T): T
    suspend onDestroy(name: String, value: T)
}
class DefaultPropertyLifecycle {
    override suspend onCreate(name: String, value: T): T
    override suspend onAccess(name: String, value: T): T
    override suspend onDestroy(name: String, value: T)
}
private class ManagedPropertyDelegate {
    -private var name: String
    -private var factory: 
    -private var lifecycle: PropertyLifecycle
    constructor(name: String, factory, lifecycle: PropertyLifecycle)
    -private var initialized
    -private var value: T
    override getValue(thisRef: Any, property: KProperty): T
}
class PlatformSpecificRepository {
    constructor()
    suspend performNativeOperation(): String
    getPlatformCapabilities(): PlatformCapabilities
}
class PlatformCapabilities {
    var supportsAdvancedFeatures: Boolean
    var nativeLibraryVersion: String
    var platformIdentifier: String
}
sealed class ProcessingState {
}
class AdvancedCoroutineScope {
    -private var context: CoroutineContext
    constructor(context: CoroutineContext)
    var coroutineContext: CoroutineContext
    asyncWithTimeout(timeout: kotlin.time.Duration, block: CoroutineScope.() -> T): Deferred<Result<T>>
}
class ProcessingPipelineBuilder {
    -private var stages
    inline transform(transformer: (T) -> R): ProcessingPipelineBuilder<R>
    filter(predicate: (T) -> Boolean): ProcessingPipelineBuilder<T>
    validate(validator: (T) -> ValidationResult): ProcessingPipelineBuilder<T>
    build(): ProcessingPipeline<T>
    -private copy(): ProcessingPipelineBuilder<R>
}
sealed class ProcessingStage {
    abstract suspend process(input: I): O
}
class TransformationStage {
    -private var transformer: 
    constructor(transformer)
    override suspend process(input: I): O
}
class FilterStage {
    -private var predicate: 
    constructor(predicate)
    override suspend process(input: T): T?
}
class ValidationStage {
    -private var validator: 
    constructor(validator)
    override suspend process(input: T): T
}
class ProcessingPipeline {
    -private var stages: List
    constructor(stages: List)
    suspend execute(input: T): ProcessingState<T, Exception>
}
class MetaEntityProcessor {
    suspend processEntity(entity: T): ProcessedEntity<T>
    -private suspend generateMethods(entity: T, annotation: AutoGenerate): Map<String, suspend () -> Any?>
    -private suspend generateBuilderMethods(entity: T): Map<String, suspend () -> Any?>
    -private suspend generateFactoryMethods(entity: T): Map<String, suspend () -> Any?>
    -private suspend generateObserverMethods(entity: T): Map<String, suspend () -> Any?>
    -private suspend generateProxyMethods(entity: T): Map<String, suspend () -> Any?>
}
data class ProcessedEntity(var original: T, var properties: List, var generatedMethods: Map) {
}
data class ProcessedProperty(var name: String, var type: KType, var value: Any, var annotations: List) {
}
sealed class DomainEvent {
    var eventId: String
    var timestamp: Long
    var source: String
}
class EventStore {
    suspend append(events: List): EventAppendResult
    suspend getEvents(streamId: String, fromVersion: Long): Flow<DomainEvent>
    suspend getEventsByType(eventType: KClass): Flow<DomainEvent>
    suspend createSnapshot(aggregateId: String, snapshot: AggregateSnapshot): SnapshotResult
}
sealed class EventAppendResult {
}
data class AggregateSnapshot(var aggregateId: String, var version: Long, var data: Map, var timestamp: Long) {
}
sealed class SnapshotResult {
}
main()
data class SampleEntity(var name: String, var value: Int) {
}
class ConfigurationWithManagedProperties {
    var databaseUrl: String
    var serviceEndpoint: String
}
sealed class ValidationResult {
}
class ValidationException {
    constructor(message: String)
}
class Query {
}
class QueryResult {
}
class ValidationRule {
}
class UserContext {
}
class Environment {
}
data class AuditInfo(var createdBy: String, var createdAt: Long) {
}
data class EntityMetadata(var tags: Set) {
}
data class PoolStatistics(var activeConnections: Int, var idleConnections: Int) {
}
class DatabaseConnection {
}
String.capitalize(): String
</file>
