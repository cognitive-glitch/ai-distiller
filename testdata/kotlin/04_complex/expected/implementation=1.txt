<file path="/home/janreges/ai-distiller/testdata/kotlin/04_complex/source.kt">
import kotlinx.coroutines
import kotlinx.coroutines.channels
import kotlinx.coroutines.flow
import kotlinx.coroutines.selects.select
import kotlin.reflect.KClass
import kotlin.reflect.KProperty
import kotlin.properties.ReadOnlyProperty
import kotlin.properties.ReadWriteProperty
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds
class DatabaseDsl {
}
class QueryBuilder {
    constructor(entityClass: KClass)
    where(condition: ConditionBuilder<T>.() -> Unit)
    orderBy(column: KProperty, direction: SortDirection)
    limit(count: Int)
    offset(count: Int)
}
class ConditionBuilder {
    KProperty<V>.eq(value: V)
    KProperty<V>.ne(value: V)
    KProperty<V>.gt(value: V)
    KProperty<V>.lt(value: V)
    KProperty<V>.isIn(values: Collection)
    ConditionBuilder<T>.and(other: ConditionBuilder<T>.() -> Unit)
    ConditionBuilder<T>.or(other: ConditionBuilder<T>.() -> Unit)
}
sealed class Condition {
}
data class OrderBy(var column: String, var direction: SortDirection) {
}
enum class SortDirection {
    ASC
    DESC
}
data class Query(var entityClass: KClass, var conditions: List, var orderBy: List, var limit: Int, var offset: Int) {
}
class AdvancedRepository {
    suspend findByQuery(query: Query): Flow<T>
    suspend executeQuery(builder: QueryBuilder<T>.() -> Unit): Flow<T>
}
data class Product(var id: String, var name: String, var price: Double, var category: String, var inStock: Boolean, var rating: Double) {
}
class ProductRepository {
    var productUpdates: SharedFlow
    override suspend findByQuery(query: Query): Flow<Product> {
= flow {
        products.asSequence()
            .filter { product -> evaluateConditions(product, query.conditions) }
            .sortedWith { a, b -> compareByOrderBy(a, b, query.orderBy) }
            .let { sequence ->
                query.offset?.let { sequence.drop(it) } ?: sequence
            }
            .let { sequence ->
                query.limit?.let { sequence.take(it) } ?: sequence
            }
            .forEach { emit(it) }
    }
    }
    override suspend executeQuery(builder: QueryBuilder<Product>.() -> Unit): Flow<Product>
    suspend addProduct(product: Product)
    suspend updateProduct(id: String, updater: (Product) -> Product): Product?
}
sealed class ProductUpdate {
}
class ProductNotificationService {
    constructor(repository: ProductRepository)
    start(): Job {
= GlobalScope.launch {
        // Collect product updates
        launch {
            repository.productUpdates.collect { update ->
                val notification = when (update) {
                    is ProductUpdate.Added -> Notification.ProductAdded(update.product.name)
                    is ProductUpdate.Modified -> Notification.ProductUpdated(
                        update.newProduct.name,
                        update.oldProduct.price,
                        update.newProduct.price
                    )
                    is ProductUpdate.Removed -> Notification.ProductRemoved(update.product.name)
                }
                notificationChannel.send(notification)
            }
        }
        
        // Distribute notifications to subscribers
        launch {
            for (notification in notificationChannel) {
                subscriptions.values.forEach { channel ->
                    channel.trySend(notification)
                }
            }
        }
    }
    }
    suspend subscribe(subscriberId: String): ReceiveChannel<Notification>
    suspend unsubscribe(subscriberId: String)
    suspend sendNotification(notification: Notification)
}
sealed class Notification {
}
class CachedProperty {
    constructor(initialValue: T, validator, ttl: Duration)
    override getValue(thisRef: Any, property: KProperty): T
    override setValue(thisRef: Any, property: KProperty, value: T)
}
class AsyncLazy {
    constructor(initializer)
    override getValue(thisRef: Any, property: KProperty): Deferred<T> {
= deferred
    }
}
class ServiceConfiguration {
    var maxConcurrentRequests: Int
    var databaseConnection: Deferred
    var isEnabled: Boolean
}
class DataProcessingOrchestrator {
    startProcessing(workerCount: Int): Job {
= GlobalScope.launch {
        // Start worker coroutines
        repeat(workerCount) { workerId ->
            launch {
                processData(workerId)
            }
        }
        
        // Error handling coroutine
        launch {
            for (error in errorChannel) {
                println("Error in worker ${error.workerId}: ${error.message}")
                // Could implement retry logic here
            }
        }
        
        // Results aggregation
        launch {
            val results = mutableListOf<ProcessingResult>()
            for (result in processingResults) {
                results.add(result)
                if (results.size >= 10) {
                    println("Processed batch of ${results.size} items")
                    results.clear()
                }
            }
        }
    }
    }
    suspend addItem(item: DataItem)
}
main() {
= runBlocking {
    // DSL Query example
    val repository = ProductRepository()
    
    println("=== DSL Query Example ===")
    repository.executeQuery {
        where {
            Product::price gt 100.0
            Product::category eq "Electronics"
            Product::inStock eq true
        }
        orderBy(Product::price, SortDirection.DESC)
        limit(3)
    }.collect { product ->
        println("Found: ${product.name} - $${product.price}")
    }
}
var notificationService
var serviceJob
var subscription
var config
var connection
var orchestrator
var processingJob
</file>
